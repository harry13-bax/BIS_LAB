import random

POP_SIZE = 6
GENOME_LENGTH = 5
GENERATIONS = 10
MUTATION_RATE = 10

class Individual:
    def __init__(self, genome=None):
        if genome is None:
            self.genome = [random.randint(0, 1) for _ in range(GENOME_LENGTH)]
        else:
            self.genome = genome
        self.fitness = self.calculate_fitness()

    def genome_to_int(self):
        value = 0
        for bit in self.genome:
            value = (value << 1) | bit
        return value

    def calculate_fitness(self):
        x = self.genome_to_int()
        return x * x

    def __repr__(self):
        return f"Genome: {''.join(map(str, self.genome))} (x={self.genome_to_int()}), Fitness={self.fitness}"

def initialize_population():
    return [Individual() for _ in range(POP_SIZE)]

def selection(population):
    fitness_sum = sum(ind.fitness for ind in population)
    pick = random.randint(0, fitness_sum - 1)
    current = 0
    for ind in population:
        current += ind.fitness
        if current > pick:
            return ind
    return population[-1]

def crossover(parent1, parent2):
    point = random.randint(1, GENOME_LENGTH - 1)
    child1_genome = parent1.genome[:point] + parent2.genome[point:]
    child2_genome = parent2.genome[:point] + parent1.genome[point:]
    return Individual(child1_genome), Individual(child2_genome)

def mutate(ind):
    for i in range(GENOME_LENGTH):
        if random.randint(0, 99) < MUTATION_RATE:
            ind.genome[i] = 1 - ind.genome[i]
    ind.fitness = ind.calculate_fitness()

def best_individual(population):
    return max(population, key=lambda ind: ind.fitness)

def genetic_algorithm():
    population = initialize_population()
    for gen in range(GENERATIONS):
        population.sort(key=lambda ind: ind.fitness, reverse=True)
        print(f"Generation {gen}: Best fitness = {population[0].fitness}, {population[0]}")
        new_population = [population[0], population[1]]
        while len(new_population) < POP_SIZE:
            parent1 = selection(population)
            parent2 = selection(population)
            child1, child2 = crossover(parent1, parent2)
            mutate(child1)
            mutate(child2)
            new_population.append(child1)
            if len(new_population) < POP_SIZE:
                new_population.append(child2)
        population = new_population
    best = best_individual(population)
    print("\nBest solution found:")
    print(best)

if __name__ == "__main__":
    random.seed()
    genetic_algorithm()
